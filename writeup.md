Many years ago, I was an avid player of racing games. Games where I could burn down the highway at 250 miles an hour, plowing through other cars with no damage to my own were the most entertaining.

There was one problem with these games: the customization. I could choose what car I wanted, what upgrades it had, and its paint color, but nothing else. But what I couldn't do was swap engines, transmissions, or even the wheels. 

As I grew older, these creativity-killing restrictions bugged me. What was the point of customization if it was so contstrained?

This question was the resaon I made this program. I wanted real customization, not the ability to buy a paint job. If I wanted to change its engine and observe the effects, i could. If I wanted to floor the virtual gas and get
real-time stats on its torque and horsepower, I could. It would be a completely transparent, fully maleable virtual car. 

I thought to myself: where should I start? Theoretically, I could make it as deep as coding each individual atom and their interactions or as surface-level as increasing the car's speed based on some mathematical function. The former 
was too difficult, and the latter was unsatisfactory. 

I decided to choose somewhere in between: a single cylinder of an engine.

```
class Cylinder
```
What parameters would I need? I started with the bore and stroke (and the resulting volume of the cylinder). The position of the piston within the cylinder would also be important, as well as the piston's current stroke.
(Note: the Cylinder class represents the piston and cylinder together.)

The basic premise behind a cylinder is the combustion of gasoline vapor creates immense pressure, pushing on the piston to generate a force. Thus, my next step was to code the 4 strokes: intake, compression, power, and exhaust.
```
def intake(self):
  pass
def spark(self):
  pass
def exhaust(self):
  pass
```
You'll notice that there is no function for compression. This is because, during the second stroke, the compression is natural result of the the piston pushing the gas vapor into a tighter area. There doesn't need to be an extra 
function because there is no special behavior happening on the second stroke.

I am no expert in chemistry or thermodynamics, so coding a realistic model of combustion seemed too far out of my scope. Instead, I decided to use the ideal gas law. This greatly simplified my task. The intake stroke would introduce some amount of air and fuel into the cylinder, increasing pressure. The compression stroke would decrease volume, raising the pressure and temperature. Then, the `spark()` function would simply raise the temperature based on the amount of gas injected, which would then increase the pressure in the cylinder.

Of course, without any oscillatory motion, these strokes didn't mean anything. The most I could do was fill the cylinder with gas, ignite it, and have the piston move in one direction for the length of the stroke. This was boring,
and it was hard to know how well it was working.

To remedy this, I decided to focus on the next most imporant part of the engine: the crankshaft.
```
class Crankshaft
```
The nice thing about a crankshaft is that it's nothing but a long piece of metal. Besides the crucial act of redirecting the force of the pistons to create rotational motion, it doesn't have any special functions.
Therefore, all I needed to do was make attributes for the angle swept by the crankshaft starting from top dead center (theta), the rotational velocity (omega), and the rotational acceleration (alpha). Then, I linked the pistons'
postions to the angle of the crankshaft using `cos(theta)`, and converted the force generated by each piston to torque using `sin(theta)`.

The hardest part of the crankshaft-cylinder combination was managing the strokes. In my initial inline 4-cylinder engine, I created a generator function that would move to the next stroke every 180 degrees. However, once I moved to the more complex inline-six, this approach stopped working. The issue was that there were 6 cylinders and only 4 strokes, so treating the strokes as discrete steps would mean multiple cylinders would be performing the same task
_at the same time._ This definitely wouldn't work because in a straight-six, the pistons change strokes at different times (instead of together every 180 degrees). To solve this, I made the strokes into continuous intervals. This allowed me to specify where each individual piston was in its stroke and made it easier to change manage their strokes independently[^1].

To me, the cylinders and the crankshaft are the most fundamental parts of the engine. The cylinders generate the force, and the crankshaft turns that force into torque. Modern combustion engines are very complex in their design and 
structure, but these are their core components (unless you're talking about rotary engines--another simple yet ingenious design).

[^1]: 



